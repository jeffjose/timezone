#!/usr/bin/env -S uv run --quiet --script
# /// script
# requires-python = ">=3.9"
# dependencies = [
#     "tzdata",
# ]
# ///

import sys
from datetime import datetime, timedelta, timezone
from zoneinfo import ZoneInfo, available_timezones
from typing import List, Tuple
import os
import subprocess
import threading
import time
import select
import termios
import tty

def get_local_timezone():
    """Get the system's local timezone"""
    # Try to get the system timezone name
    try:
        # First try reading from /etc/localtime symlink
        result = subprocess.run(['timedatectl', 'show', '--property=Timezone', '--value'],
                              capture_output=True, text=True)
        if result.returncode == 0 and result.stdout.strip():
            return ZoneInfo(result.stdout.strip())
    except:
        pass

    try:
        # Try reading /etc/timezone
        with open('/etc/timezone', 'r') as f:
            tz_name = f.read().strip()
            if tz_name:
                return ZoneInfo(tz_name)
    except:
        pass

    try:
        # Try getting from environment
        tz_name = os.environ.get('TZ')
        if tz_name:
            return ZoneInfo(tz_name)
    except:
        pass

    # Last resort - use the local timezone from datetime
    # This gives us a timezone but not necessarily the correct name
    return datetime.now().astimezone().tzinfo

def get_local_city():
    """Get the local city name based on timezone"""
    # Map common timezones to city names
    timezone_to_city = {
        'America/Los_Angeles': 'SF',
        'America/New_York': 'NYC',
        'America/Chicago': 'CHI',
        'America/Denver': 'DEN',
        'America/Phoenix': 'PHX',
        'Europe/London': 'LON',
        'Europe/Paris': 'PAR',
        'Europe/Berlin': 'BER',
        'Asia/Tokyo': 'TYO',
        'Asia/Shanghai': 'SHA',
        'Asia/Kolkata': 'DEL',
        'Australia/Sydney': 'SYD',
    }

    try:
        # Get timezone string
        result = subprocess.run(['timedatectl', 'show', '--property=Timezone', '--value'],
                              capture_output=True, text=True)
        if result.returncode == 0 and result.stdout.strip():
            tz_name = result.stdout.strip()
            # Return city if in our map, otherwise extract last part of timezone
            if tz_name in timezone_to_city:
                return timezone_to_city[tz_name]
            else:
                # Extract city from timezone (e.g., America/Los_Angeles -> LA)
                city = tz_name.split('/')[-1].replace('_', ' ')
                # Take first 3 chars for label
                return city[:3].upper()
    except:
        pass

    return "LOC"  # Default local label

def get_hours_display(base_time: datetime, tz_name: str, tz: ZoneInfo, is_local: bool = False, anchor_tz: ZoneInfo = None) -> Tuple[str, List[str]]:
    """Generate hours display for a timezone showing current time in that zone"""
    hours = []
    # Convert base_time to the target timezone to get current time there
    if isinstance(tz, ZoneInfo):
        current_time = base_time.astimezone(tz)
    else:
        # Handle case where tz might be a timezone.tzinfo object
        current_time = base_time.astimezone(tz)

    # Get the current hour in this timezone
    current_hour = current_time.hour

    # Start from midnight of current day in anchor timezone (or local if no anchor)
    if anchor_tz:
        anchor_time = datetime.now().astimezone(anchor_tz)
    else:
        anchor_time = datetime.now().astimezone()
    start_time = anchor_time.replace(hour=0, minute=0, second=0, microsecond=0)

    for hour in range(24):
        # Calculate the time for this hour slot starting from our start_time
        time_slot = start_time + timedelta(hours=hour)
        # Convert to target timezone
        time_at_hour = time_slot.astimezone(tz)

        # Format the hour
        hour_12 = time_at_hour.hour % 12
        if hour_12 == 0:
            hour_12 = 12

        # Determine AM/PM and apply coloring
        if time_at_hour.hour < 6:  # Early morning (12am-5am)
            color = '\033[90m'  # Dark gray
        elif time_at_hour.hour < 12:  # Morning (6am-11am)
            color = '\033[93m'  # Yellow
        elif time_at_hour.hour < 18:  # Afternoon (12pm-5pm)
            color = '\033[92m'  # Green
        elif time_at_hour.hour < 21:  # Evening (6pm-8pm)
            color = '\033[94m'  # Blue
        else:  # Night (9pm-11pm)
            color = '\033[95m'  # Magenta

        reset = '\033[0m'

        # Add am/pm marker
        period = 'am' if time_at_hour.hour < 12 else 'pm'

        # Check if this is the current hour
        is_current_hour = (time_at_hour.hour == current_hour)

        # Format: "12am", "1am", etc.
        # Add box drawing character for current hour
        if is_current_hour:
            hour_str = f"{color}[{hour_12:2d}{period}]{reset}"
        else:
            hour_str = f"{color}{hour_12:2d}{period}{reset}"
        hours.append(hour_str)

    # Create label with star for local timezone
    if is_local:
        label = f"{tz_name}★:".ljust(5)
    else:
        label = f"{tz_name:4s}:"

    return label, hours

def display_timezones(timezones: List[Tuple[str, str]], anchor_tz_str: str = None, debug=False):
    """Display timezone comparison grid"""
    # Get current time
    now = datetime.now(timezone.utc)

    if debug:
        print(f"DEBUG: UTC time: {now}")

    # Clear screen only in interactive mode
    # Don't clear in non-interactive mode to preserve terminal history
    # os.system('clear' if os.name != 'nt' else 'cls')

    # Color legend (no title)
    print("\n  \033[90m■\033[0m Night (12am-5am)  ", end="")
    print("\033[93m■\033[0m Morning (6am-11am)  ", end="")
    print("\033[92m■\033[0m Afternoon (12pm-5pm)  ", end="")
    print("\033[94m■\033[0m Evening (6pm-8pm)  ", end="")
    print("\033[95m■\033[0m Late (9pm-11pm)\033[0m")
    print()

    # Get anchor timezone if specified
    anchor_tz = None
    if anchor_tz_str:
        try:
            anchor_tz = ZoneInfo(anchor_tz_str)
        except:
            pass

    # Display each timezone
    for tz_label, tz_name in timezones:
        try:
            if tz_name == 'LOCAL':
                tz = get_local_timezone()
                # Get actual city name for local timezone
                city_label = get_local_city()
                # Mark as local only if it's not the anchor
                is_local = not anchor_tz_str or str(tz) != anchor_tz_str
                if debug:
                    print(f"DEBUG: Local TZ = {tz}, City = {city_label}")
            else:
                tz = ZoneInfo(tz_name)
                city_label = tz_label
                # Check if this is the anchor timezone
                is_local = False
                if debug:
                    print(f"DEBUG: {tz_name} = {tz}")

            # Check if this is the anchor (gets the star)
            is_anchor = anchor_tz_str and str(tz) == anchor_tz_str

            label, hours = get_hours_display(now, city_label, tz,
                                            is_local=(is_local and not anchor_tz_str) or is_anchor,
                                            anchor_tz=anchor_tz)

            # Print timezone row with day separator
            print(f"{label} ", end="")
            for i, hour in enumerate(hours):
                print(f"{hour:4s} ", end="")
                # Add separator after 11pm (at position 23) to show day boundary
                if i == 23:  # After 11pm, before what would be next midnight
                    print(" \033[90m|\033[0m", end="")
            print()

        except Exception as e:
            print(f"Error with timezone {tz_name}: {e}")

    print()

def show_help():
    """Display help menu"""
    print("\nCommands:")
    print("  a <timezone>  - Add a timezone (e.g., 'a America/New_York' or 'a NY America/New_York')")
    print("  r <label>     - Remove a timezone by label")
    print("  l             - List common timezones")
    print("  h             - Show this help")
    print("  q             - Quit")
    print()

def list_common_timezones():
    """List common timezones"""
    common_tzs = [
        "America/New_York (NY - Eastern Time)",
        "America/Chicago (CHI - Central Time)",
        "America/Denver (DEN - Mountain Time)",
        "America/Los_Angeles (LA - Pacific Time)",
        "Europe/London (LON - GMT/BST)",
        "Europe/Paris (PAR - Central European)",
        "Europe/Berlin (BER - Central European)",
        "Asia/Tokyo (TYO - Japan Time)",
        "Asia/Shanghai (SHA - China Time)",
        "Asia/Kolkata (DEL - India Time)",
        "Asia/Dubai (DXB - Gulf Time)",
        "Australia/Sydney (SYD - Australian Eastern)",
        "Pacific/Auckland (AKL - New Zealand)",
    ]
    print("\nCommon timezones:")
    for tz in common_tzs:
        print(f"  {tz}")
    print()

def get_input_nonblocking():
    """Get input without blocking"""
    old_settings = termios.tcgetattr(sys.stdin)
    try:
        tty.setraw(sys.stdin.fileno())
        if select.select([sys.stdin], [], [], 0) == ([sys.stdin], [], []):
            return sys.stdin.read(1)
    finally:
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
    return None

def resolve_city_to_timezone(city_input):
    """Resolve a city name (partial or full) to a timezone"""
    # Common city mappings
    city_mappings = {
        'sf': 'America/Los_Angeles',
        'san francisco': 'America/Los_Angeles',
        'la': 'America/Los_Angeles',
        'los angeles': 'America/Los_Angeles',
        'nyc': 'America/New_York',
        'new york': 'America/New_York',
        'chicago': 'America/Chicago',
        'chi': 'America/Chicago',
        'denver': 'America/Denver',
        'den': 'America/Denver',
        'phoenix': 'America/Phoenix',
        'phx': 'America/Phoenix',
        'london': 'Europe/London',
        'lon': 'Europe/London',
        'paris': 'Europe/Paris',
        'par': 'Europe/Paris',
        'berlin': 'Europe/Berlin',
        'ber': 'Europe/Berlin',
        'amsterdam': 'Europe/Amsterdam',
        'ams': 'Europe/Amsterdam',
        'tokyo': 'Asia/Tokyo',
        'tyo': 'Asia/Tokyo',
        'seoul': 'Asia/Seoul',
        'sel': 'Asia/Seoul',
        'taiwan': 'Asia/Taipei',
        'taipei': 'Asia/Taipei',
        'tpe': 'Asia/Taipei',
        'shanghai': 'Asia/Shanghai',
        'sha': 'Asia/Shanghai',
        'beijing': 'Asia/Shanghai',  # Same timezone
        'hong kong': 'Asia/Hong_Kong',
        'hkg': 'Asia/Hong_Kong',
        'singapore': 'Asia/Singapore',
        'sin': 'Asia/Singapore',
        'mumbai': 'Asia/Kolkata',
        'delhi': 'Asia/Kolkata',
        'del': 'Asia/Kolkata',
        'india': 'Asia/Kolkata',
        'ind': 'Asia/Kolkata',
        'dubai': 'Asia/Dubai',
        'dxb': 'Asia/Dubai',
        'sydney': 'Australia/Sydney',
        'syd': 'Australia/Sydney',
        'melbourne': 'Australia/Melbourne',
        'mel': 'Australia/Melbourne',
        'auckland': 'Pacific/Auckland',
        'akl': 'Pacific/Auckland',
    }

    # Try exact match first (case-insensitive)
    city_lower = city_input.lower()
    if city_lower in city_mappings:
        return city_mappings[city_lower], city_input.upper()[:3]

    # Try partial match
    for key, value in city_mappings.items():
        if city_lower in key or key.startswith(city_lower):
            # Generate label from the matched city
            return value, key.split()[0].upper()[:3]

    # If it looks like a timezone path, use it directly
    if '/' in city_input:
        try:
            ZoneInfo(city_input)  # Validate it
            label = city_input.split('/')[-1][:3].upper()
            return city_input, label
        except:
            pass

    return None, None

def main():
    import argparse
    parser = argparse.ArgumentParser(description='Timezone comparison tool')
    parser.add_argument('cities', nargs='*', help='Cities to display (use @ suffix to anchor, e.g., london@)')
    parser.add_argument('--interactive', '-i', action='store_true',
                       help='Run in interactive mode')
    parser.add_argument('--debug', '-d', action='store_true',
                       help='Enable debug output')
    args = parser.parse_args()

    # Process city arguments
    anchor_city = None
    cities_to_show = []

    if args.cities:
        for city in args.cities:
            # Check if this is the anchor city (ends with @)
            if city.endswith('@'):
                city = city[:-1]
                tz, label = resolve_city_to_timezone(city)
                if tz:
                    anchor_city = (label, tz)
                    cities_to_show.append((label, tz))
                else:
                    print(f"Warning: Could not resolve city '{city}'")
            else:
                tz, label = resolve_city_to_timezone(city)
                if tz:
                    cities_to_show.append((label, tz))
                else:
                    print(f"Warning: Could not resolve city '{city}'")

    # Set up timezones list
    timezones = []

    # Add local timezone first (unless it's the anchor or already in list)
    local_tz_str = subprocess.run(['timedatectl', 'show', '--property=Timezone', '--value'],
                                  capture_output=True, text=True).stdout.strip()
    local_city = get_local_city()
    local_entry = (local_city, "LOCAL")

    # Set up which timezones we've seen
    seen_tzs = set()

    # If we have an anchor city that's the same as local, show it with the anchor label
    if anchor_city and anchor_city[1] == local_tz_str:
        timezones.append((anchor_city[0], "LOCAL"))  # Use anchor label, LOCAL timezone
        seen_tzs.add(local_tz_str)
    else:
        # Otherwise, show local with its own label
        timezones.append(local_entry)
        seen_tzs.add(local_tz_str)

    # Add specified cities (avoiding duplicates)
    for label, tz in cities_to_show:
        # Skip if already added (including anchor which is in cities_to_show)
        if tz not in seen_tzs and tz != "LOCAL":
            timezones.append((label, tz))
            seen_tzs.add(tz)

    # If no cities specified, default to showing London
    if not args.cities and len(timezones) == 1:
        if "Europe/London" not in seen_tzs:
            timezones.append(("LON", "Europe/London"))

    # Default: non-interactive mode - just display and exit
    if not args.interactive:
        # Pass anchor timezone if specified
        anchor_tz_str = anchor_city[1] if anchor_city else None
        display_timezones(timezones, anchor_tz_str=anchor_tz_str, debug=args.debug)
        return

    # Interactive mode
    # Keep track of whether we need to refresh
    refresh = True
    command_buffer = ""
    entering_command = False

    print("Timezone Overlap Tool")
    print("Press '?' for help, 'q' to quit")
    print()

    try:
        # Save terminal settings
        old_settings = termios.tcgetattr(sys.stdin)

        while True:
            if refresh and not entering_command:
                display_timezones(timezones)
                print("\nCommands: (a)dd, (r)emove, (l)ist, (h)elp, (q)uit")
                print("> ", end="", flush=True)
                refresh = False

            # Check for input
            tty.setraw(sys.stdin.fileno())
            if select.select([sys.stdin], [], [], 0.1) == ([sys.stdin], [], []):
                char = sys.stdin.read(1)
                termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)

                if char == 'q':
                    print("\nExiting...")
                    break
                elif char == 'h' or char == '?':
                    show_help()
                    refresh = True
                elif char == 'l':
                    list_common_timezones()
                    refresh = True
                elif char == 'a':
                    print("\nAdd timezone (format: 'label timezone' or just 'timezone'): ", end="", flush=True)
                    cmd_input = input().strip()
                    if cmd_input:
                        parts = cmd_input.split()
                        if len(parts) == 2:
                            label, tz_name = parts
                            label = label[:4].upper()  # Limit label to 4 chars
                        elif len(parts) == 1:
                            tz_name = parts[0]
                            # Generate label from timezone name
                            label = tz_name.split('/')[-1][:3].upper()
                        else:
                            print("Invalid format")
                            time.sleep(1)
                            refresh = True
                            continue

                        try:
                            # Validate timezone
                            ZoneInfo(tz_name)
                            # Check if already exists
                            if any(l == label for l, _ in timezones):
                                print(f"Label {label} already exists")
                                time.sleep(1)
                            else:
                                timezones.append((label, tz_name))
                                print(f"Added {label}: {tz_name}")
                                time.sleep(0.5)
                        except Exception as e:
                            print(f"Invalid timezone: {tz_name}")
                            time.sleep(1)
                    refresh = True
                elif char == 'r':
                    print("\nRemove timezone (enter label): ", end="", flush=True)
                    label = input().strip().upper()
                    if label == "CURR":
                        print("Cannot remove current timezone")
                        time.sleep(1)
                    else:
                        original_len = len(timezones)
                        timezones[:] = [(l, tz) for l, tz in timezones if l != label]
                        if len(timezones) < original_len:
                            print(f"Removed {label}")
                        else:
                            print(f"Label {label} not found")
                        time.sleep(0.5)
                    refresh = True
                elif char == '\x03':  # Ctrl+C
                    raise KeyboardInterrupt
                else:
                    # Unknown command, just refresh
                    refresh = True
            else:
                termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)

            # Auto-refresh every 60 seconds to update time
            time.sleep(0.1)

    except KeyboardInterrupt:
        print("\n\nExiting...")
    finally:
        # Restore terminal settings
        try:
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
        except:
            pass
        sys.exit(0)

if __name__ == "__main__":
    main()